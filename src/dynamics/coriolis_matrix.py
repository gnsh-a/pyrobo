"""
Coriolis matrix (B matrix) computation for the 3-DOF RRR manipulator.

This file was AUTO-GENERATED by scripts/generate_dynamics.py
Generated on: 2025-12-10 21:28:30

DO NOT EDIT THIS FILE MANUALLY!
To regenerate, run: python scripts/generate_dynamics.py
"""

import numpy as np


def compute_B(q, L, m, g, I):
    """
    Compute the B matrix (Coriolis matrix) matrix/vector.
    
    This function was derived symbolically from first principles using
    Lagrangian mechanics and then optimized for computational efficiency.
    
    Parameters
    ----------
    q : array_like (3,)
        Joint angles [q1, q2, q3] in radians
    L : float
        Link length parameter
    m : float
        Link mass
    g : float
        Gravitational acceleration
    I : float
        Link inertia (perpendicular to link centerline)
        
    
    The Coriolis matrix multiplies the vector of velocity products:
    [q1_dot*q2_dot, q1_dot*q3_dot, q2_dot*q3_dot]^T
    
    Returns
n    -------
    B : ndarray
        B matrix (Coriolis matrix)
        
    Notes
    -----
    Derived from Lagrangian mechanics using the following steps:
    1. Forward kinematics → Transformation matrices
    2. Jacobians → Linear and angular velocity mappings
    3. Lagrangian → Kinetic and potential energy
    4. Euler-Lagrange equations → Equations of motion
    """
    q = np.asarray(q)
    q1, q2, q3 = q[0], q[1], q[2]
    
    # Precompute common subexpressions
    t0 = np.cos(q2)
    t1 = np.sin(q3)
    t2 = t1**2
    t3 = L**2*m
    t4 = np.cos(q3)
    t5 = t0**2*t4
    t6 = 2*I
    t7 = t4**2
    t8 = (1/2)*t0
    t9 = t8*(I + t2*t3 + t2*t6)
    
    # Construct B matrix using column-major (Fortran) order
    B = np.array([
        t0*t2*(I + (1/2)*t3)*np.sin(q2),
        0,
        -t9,
        -1/2*t1*(t3*(t5 + 2) + t5*t6),
        t9,
        0,
        -t8*(I + 2*t3*t4 + t3*t7 + t6*t7),
        ((1/2)*I + (1/4)*t3)*np.sin(2*q3),
        0
    ]).reshape(3, 3, order='F')
    
    return B
