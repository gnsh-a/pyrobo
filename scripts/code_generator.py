"""
Code generation utilities for converting symbolic expressions to Python code.

Generates optimized NumPy functions from SymPy expressions.
"""

import sympy as sp
from datetime import datetime


def generate_function_header(function_name, matrix_name, description):
    """Generate function docstring and signature."""
    
    header = f'''"""
{description}

This file was AUTO-GENERATED by scripts/generate_dynamics.py
Generated on: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

DO NOT EDIT THIS FILE MANUALLY!
To regenerate, run: python scripts/generate_dynamics.py
"""

import numpy as np


def {function_name}(q, L, m, g, I):
    """
    Compute the {matrix_name} matrix/vector.
    
    This function was derived symbolically from first principles using
    Lagrangian mechanics and then optimized for computational efficiency.
    
    Parameters
    ----------
    q : array_like (3,)
        Joint angles [q1, q2, q3] in radians
    L : float
        Link length parameter
    m : float
        Link mass
    g : float
        Gravitational acceleration
    I : float
        Link inertia (perpendicular to link centerline)
        
    Returns
    -------
    {matrix_name.split()[0]} : ndarray
        {matrix_name}
        
    Notes
    -----
    Derived from Lagrangian mechanics using the following steps:
    1. Forward kinematics → Transformation matrices
    2. Jacobians → Linear and angular velocity mappings
    3. Lagrangian → Kinetic and potential energy
    4. Euler-Lagrange equations → Equations of motion
    """
    q = np.asarray(q)
    q1, q2, q3 = q[0], q[1], q[2]
    
'''
    return header


def generate_d_matrix_code(D_symbolic, q_symbols):
    """
    Generate optimized Python code for D matrix computation.
    
    Parameters
    ----------
    D_symbolic : sympy.Matrix
        Symbolic mass matrix
    q_symbols : list
        List of symbolic variables [q1, q2, q3]
        
    Returns
    -------
    str
        Python code for compute_D function
    """
    print("Generating Python code for D matrix...")
    
    # Generate header
    code = generate_function_header(
        'compute_D',
        'D matrix (Mass matrix)',
        'Mass matrix (D matrix) computation for the 3-DOF RRR manipulator.'
    )
    
    # Use common subexpression elimination for efficiency
    print("  Applying common subexpression elimination...")
    subexprs, simplified = sp.cse(D_symbolic, symbols=sp.numbered_symbols('t'))
    
    # Generate code for subexpressions
    code += "    # Precompute common subexpressions\n"
    for var, expr in subexprs:
        expr_code = sp.pycode(expr)
        # Replace math functions with numpy equivalents
        expr_code = expr_code.replace('math.sin', 'np.sin')
        expr_code = expr_code.replace('math.cos', 'np.cos')
        expr_code = expr_code.replace('math.tan', 'np.tan')
        expr_code = expr_code.replace('math.sqrt', 'np.sqrt')
        expr_code = expr_code.replace('math.', 'np.')
        code += f"    {var} = {expr_code}\n"
    
    code += "    \n"
    code += "    # Construct D matrix using column-major (Fortran) order\n"
    code += "    D = np.array([\n"
    
    # Generate matrix elements (column-major order)
    elements = []
    for j in range(3):
        for i in range(3):
            elements.append(simplified[0][i, j])
    
    for i, elem in enumerate(elements):
        elem_code = sp.pycode(elem)
        # Replace math functions with numpy equivalents
        elem_code = elem_code.replace('math.sin', 'np.sin')
        elem_code = elem_code.replace('math.cos', 'np.cos')
        elem_code = elem_code.replace('math.tan', 'np.tan')
        elem_code = elem_code.replace('math.sqrt', 'np.sqrt')
        elem_code = elem_code.replace('math.', 'np.')
        if i < len(elements) - 1:
            code += f"        {elem_code},\n"
        else:
            code += f"        {elem_code}\n"
    
    code += "    ]).reshape(3, 3, order='F')\n"
    code += "    \n"
    code += "    return D\n"
    
    return code


def generate_b_matrix_code(B_symbolic, q_symbols):
    """Generate optimized Python code for B matrix computation."""
    print("Generating Python code for B matrix...")
    
    code = generate_function_header(
        'compute_B',
        'B matrix (Coriolis matrix)',
        'Coriolis matrix (B matrix) computation for the 3-DOF RRR manipulator.'
    )
    
    # Add explanation of what B multiplies
    code = code.replace(
        "    Returns\n",
        """    
    The Coriolis matrix multiplies the vector of velocity products:
    [q1_dot*q2_dot, q1_dot*q3_dot, q2_dot*q3_dot]^T
    
    Returns
n"""
    )
    
    # Common subexpression elimination
    print("  Applying common subexpression elimination...")
    subexprs, simplified = sp.cse(B_symbolic, symbols=sp.numbered_symbols('t'))
    
    code += "    # Precompute common subexpressions\n"
    for var, expr in subexprs:
        expr_code = sp.pycode(expr)
        # Replace math functions with numpy equivalents
        expr_code = expr_code.replace('math.sin', 'np.sin')
        expr_code = expr_code.replace('math.cos', 'np.cos')
        expr_code = expr_code.replace('math.tan', 'np.tan')
        expr_code = expr_code.replace('math.sqrt', 'np.sqrt')
        expr_code = expr_code.replace('math.', 'np.')
        code += f"    {var} = {expr_code}\n"
    
    code += "    \n"
    code += "    # Construct B matrix using column-major (Fortran) order\n"
    code += "    B = np.array([\n"
    
    # Generate matrix elements
    elements = []
    for j in range(3):
        for i in range(3):
            elements.append(simplified[0][i, j])
    
    for i, elem in enumerate(elements):
        elem_code = sp.pycode(elem)
        # Replace math functions with numpy equivalents
        elem_code = elem_code.replace('math.sin', 'np.sin')
        elem_code = elem_code.replace('math.cos', 'np.cos')
        elem_code = elem_code.replace('math.tan', 'np.tan')
        elem_code = elem_code.replace('math.sqrt', 'np.sqrt')
        elem_code = elem_code.replace('math.', 'np.')
        if i < len(elements) - 1:
            code += f"        {elem_code},\n"
        else:
            code += f"        {elem_code}\n"
    
    code += "    ]).reshape(3, 3, order='F')\n"
    code += "    \n"
    code += "    return B\n"
    
    return code


def generate_c_matrix_code(C_symbolic, q_symbols):
    """Generate optimized Python code for C matrix computation."""
    print("Generating Python code for C matrix...")
    
    code = generate_function_header(
        'compute_C',
        'C matrix (Centrifugal matrix)',
        'Centrifugal matrix (C matrix) computation for the 3-DOF RRR manipulator.'
    )
    
    # Add explanation of what C multiplies
    code = code.replace(
        "    Returns\n",
        """    
    The centrifugal matrix multiplies the vector of squared velocities:
    [q1_dot^2, q2_dot^2, q3_dot^2]^T
    
    Returns
n"""
    )
    
    # Common subexpression elimination
    print("  Applying common subexpression elimination...")
    subexprs, simplified = sp.cse(C_symbolic, symbols=sp.numbered_symbols('t'))
    
    code += "    # Precompute common subexpressions\n"
    for var, expr in subexprs:
        expr_code = sp.pycode(expr)
        # Replace math functions with numpy equivalents
        expr_code = expr_code.replace('math.sin', 'np.sin')
        expr_code = expr_code.replace('math.cos', 'np.cos')
        expr_code = expr_code.replace('math.tan', 'np.tan')
        expr_code = expr_code.replace('math.sqrt', 'np.sqrt')
        expr_code = expr_code.replace('math.', 'np.')
        code += f"    {var} = {expr_code}\n"
    
    code += "    \n"
    code += "    # Construct C matrix using column-major (Fortran) order\n"
    code += "    C = np.array([\n"
    
    # Generate matrix elements
    elements = []
    for j in range(3):
        for i in range(3):
            elements.append(simplified[0][i, j])
    
    for i, elem in enumerate(elements):
        elem_code = sp.pycode(elem)
        # Replace math functions with numpy equivalents
        elem_code = elem_code.replace('math.sin', 'np.sin')
        elem_code = elem_code.replace('math.cos', 'np.cos')
        elem_code = elem_code.replace('math.tan', 'np.tan')
        elem_code = elem_code.replace('math.sqrt', 'np.sqrt')
        elem_code = elem_code.replace('math.', 'np.')
        if i < len(elements) - 1:
            code += f"        {elem_code},\n"
        else:
            code += f"        {elem_code}\n"
    
    code += "    ]).reshape(3, 3, order='F')\n"
    code += "    \n"
    code += "    return C\n"
    
    return code


def generate_g_vector_code(G_symbolic, q_symbols):
    """Generate optimized Python code for G vector computation."""
    print("Generating Python code for G vector...")
    
    code = generate_function_header(
        'compute_G',
        'G vector (Gravity vector)',
        'Gravity vector (G vector) computation for the 3-DOF RRR manipulator.'
    )
    
    # Common subexpression elimination
    print("  Applying common subexpression elimination...")
    subexprs, simplified = sp.cse(G_symbolic, symbols=sp.numbered_symbols('t'))
    
    if subexprs:
        code += "    # Precompute common subexpressions\n"
        for var, expr in subexprs:
            expr_code = sp.pycode(expr)
            # Replace math functions with numpy equivalents
            expr_code = expr_code.replace('math.sin', 'np.sin')
            expr_code = expr_code.replace('math.cos', 'np.cos')
            expr_code = expr_code.replace('math.tan', 'np.tan')
            expr_code = expr_code.replace('math.sqrt', 'np.sqrt')
            expr_code = expr_code.replace('math.', 'np.')
            code += f"    {var} = {expr_code}\n"
        code += "    \n"
    
    code += "    # Compute gravity vector components\n"
    code += "    G = np.array([\n"
    
    for i in range(3):
        elem_code = sp.pycode(simplified[0][i])
        # Replace math functions with numpy equivalents
        elem_code = elem_code.replace('math.sin', 'np.sin')
        elem_code = elem_code.replace('math.cos', 'np.cos')
        elem_code = elem_code.replace('math.tan', 'np.tan')
        elem_code = elem_code.replace('math.sqrt', 'np.sqrt')
        elem_code = elem_code.replace('math.', 'np.')
        if i < 2:
            code += f"        {elem_code},\n"
        else:
            code += f"        {elem_code}\n"
    
    code += "    ])\n"
    code += "    \n"
    code += "    return G\n"
    
    return code


def write_generated_code(code, filepath):
    """Write generated code to file."""
    with open(filepath, 'w') as f:
        f.write(code)
    print(f"  Written to {filepath}")

